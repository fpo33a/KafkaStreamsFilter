/*

TEST Kafka Stream aggregation using hopping window based on business date ( see SensorRecordDateTimeExtractor )

// create an input topic
C:\frank\apache-kafka-2.4.1\bin\windows>kafka-topics.bat  --zookeeper localhost:2181 --create --replication-factor 1 --partitions 1 --topic test
Created topic test.

// check content of input topic ( generated by uncommenting some code to put some data )
C:\frank\apache-kafka-2.4.1\bin\windows>kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test
Processed a total of 0 messages
Terminer le programme de commandes (O/N) ? o

C:\frank\apache-kafka-2.4.1\bin\windows>kafka-console-consumer.bat --bootstrap-server localhost:9092 --topic test --from-beginning
{ "SensorId": "Key0", "datetime": "2021/11/13 14:24:24","SensorValue": 1}
{ "SensorId": "Key1", "datetime": "2021/11/13 14:24:26","SensorValue": 101}
{ "SensorId": "Key2", "datetime": "2021/11/13 14:24:26","SensorValue": 201}
{ "SensorId": "Key3", "datetime": "2021/11/13 14:24:26","SensorValue": 302}
{ "SensorId": "Key4", "datetime": "2021/11/13 14:24:26","SensorValue": 404}
{ "SensorId": "Key0", "datetime": "2021/11/13 14:24:26","SensorValue": 9}
{ "SensorId": "Key1", "datetime": "2021/11/13 14:24:27","SensorValue": 104}
{ "SensorId": "Key2", "datetime": "2021/11/13 14:24:27","SensorValue": 208}
{ "SensorId": "Key3", "datetime": "2021/11/13 14:24:27","SensorValue": 310}
{ "SensorId": "Key4", "datetime": "2021/11/13 14:24:27","SensorValue": 408}
{ "SensorId": "Key0", "datetime": "2021/11/13 14:24:27","SensorValue": 3}
{ "SensorId": "Key1", "datetime": "2021/11/13 14:24:28","SensorValue": 104}
{ "SensorId": "Key2", "datetime": "2021/11/13 14:24:28","SensorValue": 203}
{ "SensorId": "Key3", "datetime": "2021/11/13 14:24:28","SensorValue": 301}
{ "SensorId": "Key4", "datetime": "2021/11/13 14:24:28","SensorValue": 404}
{ "SensorId": "Key0", "datetime": "2021/11/13 14:24:28","SensorValue": 7}
{ "SensorId": "Key1", "datetime": "2021/11/13 14:24:29","SensorValue": 106}
{ "SensorId": "Key2", "datetime": "2021/11/13 14:24:29","SensorValue": 203}
{ "SensorId": "Key3", "datetime": "2021/11/13 14:24:29","SensorValue": 305}
{ "SensorId": "Key4", "datetime": "2021/11/13 14:24:29","SensorValue": 401}
Processed a total of 20 messages
Terminer le programme de commandes (O/N) ? o

// chec Output results : ( key is time window ( so record key @ start window epoch / end window epoch

2021/11/13 14:52:37>Starting data generator thread ...
2021/11/13 14:52:37>Initializing stream ...
SLF4J: Failed to load class "org.slf4j.impl.StaticLoggerBinder".
SLF4J: Defaulting to no-operation (NOP) logger implementation
SLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.
2021/11/13 14:52:40>Starting ...
>   map : [Key0@1636809855000/1636809865000] : NB ELE : 1 : TOTAL : 1 : MEAN : 1.0 : STDDEV : 0.0 : VALUES : 1
>   map : [Key0@1636809860000/1636809870000] : NB ELE : 4 : TOTAL : 20 : MEAN : 5.0 : STDDEV : 3.1622776601683795 : VALUES : 1,9,3,7
>   map : [Key0@1636809865000/1636809875000] : NB ELE : 3 : TOTAL : 19 : MEAN : 6.333333333333333 : STDDEV : 2.494438257849294 : VALUES : 9,3,7
>   map : [Key1@1636809860000/1636809870000] : NB ELE : 4 : TOTAL : 415 : MEAN : 103.75 : STDDEV : 1.7853571071357126 : VALUES : 101,104,104,106
>   map : [Key1@1636809865000/1636809875000] : NB ELE : 4 : TOTAL : 415 : MEAN : 103.75 : STDDEV : 1.7853571071357126 : VALUES : 101,104,104,106
>   map : [Key2@1636809860000/1636809870000] : NB ELE : 4 : TOTAL : 815 : MEAN : 203.75 : STDDEV : 2.5860201081971503 : VALUES : 201,208,203,203
>   map : [Key2@1636809865000/1636809875000] : NB ELE : 4 : TOTAL : 815 : MEAN : 203.75 : STDDEV : 2.5860201081971503 : VALUES : 201,208,203,203
>   map : [Key3@1636809860000/1636809870000] : NB ELE : 4 : TOTAL : 1218 : MEAN : 304.5 : STDDEV : 3.5 : VALUES : 302,310,301,305
>   map : [Key3@1636809865000/1636809875000] : NB ELE : 4 : TOTAL : 1218 : MEAN : 304.5 : STDDEV : 3.5 : VALUES : 302,310,301,305
>   map : [Key4@1636809860000/1636809870000] : NB ELE : 4 : TOTAL : 1617 : MEAN : 404.25 : STDDEV : 2.48746859276655 : VALUES : 404,408,404,401
>   map : [Key4@1636809865000/1636809875000] : NB ELE : 4 : TOTAL : 1617 : MEAN : 404.25 : STDDEV : 2.48746859276655 : VALUES : 404,408,404,401


 */

import org.apache.kafka.common.serialization.Deserializer;
import org.apache.kafka.common.serialization.Serdes;
import org.apache.kafka.common.serialization.Serializer;
import org.apache.kafka.streams.KafkaStreams;
import org.apache.kafka.streams.KeyValue;
import org.apache.kafka.streams.StreamsBuilder;
import org.apache.kafka.streams.StreamsConfig;
import org.apache.kafka.streams.kstream.*;



import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.time.Duration;
import java.util.Date;
import java.util.Properties;
import java.util.UUID;

public class KafkaStreamAggregate {

    private final static DateFormat dateFormat = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
    private final String bootstrapServer = "localhost:9092";
    private final String applicationId = "testAggregateBaseOnBusinessDate";
    private final String topicName = "test";
    private boolean verbose = true;

    //-------------------------------------------------------------------


    public static void main(String[] args) {
        KafkaStreamAggregate test = new KafkaStreamAggregate();

        test.aggregate (args);
        return;
    }

    //-------------------------------------------------------------------

    private void print(String data) {
        if (this.verbose) System.out.println(data);
    }

    //-------------------------------------------------------------------

    private void aggregate(String[] args) {
        Properties props = new Properties();
        props.put(StreamsConfig.APPLICATION_ID_CONFIG, this.applicationId);
        props.put(StreamsConfig.BOOTSTRAP_SERVERS_CONFIG, this.bootstrapServer);
        props.put(StreamsConfig.DEFAULT_KEY_SERDE_CLASS_CONFIG, Serdes.String().getClass());
        props.put(StreamsConfig.DEFAULT_VALUE_SERDE_CLASS_CONFIG, Serdes.String().getClass());
        props.put(StreamsConfig.DEFAULT_TIMESTAMP_EXTRACTOR_CLASS_CONFIG, SensorRecordDateTimeExtractor.class.getName()); // to extract business date from record
        props.put(StreamsConfig.COMMIT_INTERVAL_MS_CONFIG, 1000);

        // generate some data into input topic
        this.print(dateFormat.format(new Date()) + ">Starting data generator thread ...");

/* UNCOMMENT to generate some data
        DataGenerator dataGenerator = new DataGenerator();
        dataGenerator.init(this.verbose, this.bootstrapServer, this.topicName);
        Thread dataGeneratorThread = new Thread(dataGenerator);
        dataGeneratorThread.start();
*/
        this.print(dateFormat.format(new Date()) + ">Initializing stream ...");
        final StreamsBuilder builder = new StreamsBuilder();

        Serializer<SensorAggregator> serializer = new Serializer<SensorAggregator>() {
            @Override
            public byte[] serialize(String s, SensorAggregator sensorAggregator) {
                return sensorAggregator.serializeValues();
            }
        } ;
        Deserializer<SensorAggregator> deserializer = new Deserializer<SensorAggregator>() {
            @Override
            public SensorAggregator deserialize(String s, byte[] bytes) {
                SensorAggregator sensorAggregator = new SensorAggregator();
                sensorAggregator.deserializeValues(new String(bytes));
                return  (sensorAggregator);
            }
        } ;

        KTable<Windowed<String>, SensorAggregator> testTable = builder.stream(this.topicName, Consumed.with(Serdes.String(), Serdes.String()))
                .groupByKey()
                //Add a 10 second window and slide the hopping time window in 5 second steps
                .windowedBy(TimeWindows.of(Duration.ofSeconds(10).toMillis()).advanceBy(Duration.ofSeconds(5).toMillis()))
                .aggregate(SensorAggregator::new,
                           (aggKey, newValue, aggValue) -> {
                            aggValue.setData(newValue);
                            return aggValue;
                            },
                            Materialized.with(Serdes.String(), Serdes.serdeFrom(serializer, deserializer)
                           )
                );

        KStream<Windowed<String>, SensorAggregator> testStream = testTable.toStream()
                .map((Windowed<String> key, SensorAggregator value) -> {
                    System.out.println(">   map : " + key   + " : NB ELE : " +  value.getNbElement() + " : TOTAL : " + value.getTotal() + " : MEAN : " + value.getMean() + " : STDDEV : " + value.getStandardDeviation()+ " : VALUES : "+value.dump());
                    return new KeyValue<>(key, value);
                });

        KafkaStreams streams = new KafkaStreams(builder.build(), props);
        this.print(dateFormat.format(new Date()) + ">Starting ...");
        streams.start();

        Runtime.getRuntime().addShutdownHook(new Thread(streams::close));
    }

    //--------------------------------------------------

}

